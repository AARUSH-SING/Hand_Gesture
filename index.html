<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive 3D Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 24px; pointer-events: none;
        }
        #video-container {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            width: 160px; height: 120px; border: 2px solid #333;
            transform: scaleX(-1); /* Mirror the video */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

<div id="loading">Loading AI Models...</div>
<div id="video-container">
    <video id="input_video" autoplay playsinline></video>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.15;
    const TRANSITION_SPEED = 0.05; // 0.0 to 1.0 (Lerp factor)

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targets = new Float32Array(PARTICLE_COUNT * 3); // Target positions for morphing
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    // Initial random positions
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        targets[i] = positions[i];
        colors[i] = 1; // White initially
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- SHAPE GENERATORS ---
    // Helper to set target array based on a math function
    function setShape(type) {
        console.log("Switching to shape:", type);
        let x, y, z;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            if (type === 'cube') {
                const size = 15;
                x = (Math.random() - 0.5) * size;
                y = (Math.random() - 0.5) * size;
                z = (Math.random() - 0.5) * size;
            } 
            else if (type === 'sphere') {
                const r = 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } 
            else if (type === 'heart') {
                // Heart parametric equation
                const t = Math.random() * Math.PI * 2; // angle
                const h = Math.random() * 20 - 10; // height slice
                // Simple 3D heart approximation
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                // We stack layers in Z
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                // Using a simpler volume fill approach for stability
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random() - 0.5) * 10;
                
                // Scale down
                x *= 0.5; y *= 0.5;
            } 
            else if (type === 'saturn') {
                const r = Math.random();
                // 70% particles in the planet, 30% in the ring
                if (r > 0.3) {
                    // Planet
                    const radius = 6;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * Math.cos(phi);
                } else {
                    // Ring
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 6;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                    y = (Math.random() - 0.5) * 0.5; // Thin ring
                    
                    // Tilt the ring
                    const tilt = 0.4;
                    const tempY = y;
                    y = y * Math.cos(tilt) - z * Math.sin(tilt);
                    z = tempY * Math.sin(tilt) + z * Math.cos(tilt);
                }
            }
            else if (type === 'flower') {
                 // Rose curve polar coordinates
                 const k = 4; // petals
                 const theta = Math.random() * Math.PI * 2;
                 const radius = 10 * Math.cos(k * theta);
                 x = radius * Math.cos(theta);
                 y = radius * Math.sin(theta);
                 z = (Math.random() - 0.5) * 5;
            }

            targets[i3] = x;
            targets[i3 + 1] = y;
            targets[i3 + 2] = z;
        }
    }

    // Shapes sequence
    const shapes = ['sphere', 'cube', 'heart', 'saturn', 'flower'];
    let currentShapeIndex = 0;
    setShape(shapes[0]);

    // --- INTERACTION STATE ---
    let handPos = { x: 0, y: 0, z: 0 }; // Normalized -1 to 1
    let isHandPresent = false;
    let isPinching = false;
    let lastGestureTime = 0;

    // --- MEDIAPIPE HANDS SETUP ---
    const videoElement = document.getElementById('input_video');
    
    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandPresent = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. Track Index Finger Tip (Landmark 8)
            // Map 0..1 video coords to -15..15 3D world coords
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];

            // Update Hand Position for physics (Mirror X)
            handPos.x = (0.5 - indexTip.x) * 30; 
            handPos.y = (0.5 - indexTip.y) * 20; 
            
            // 2. Detect Pinch (Index tip close to Thumb tip)
            const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            isPinching = pinchDist < 0.05;

            // 3. Detect Fist (Gesture to switch shapes)
            // Heuristic: Tips of fingers are close to the wrist
            const fingersClosed = [indexTip, middleTip, ringTip, pinkyTip].every(tip => {
                const distToWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                return distToWrist < 0.15; // Threshold for "closed"
            });

            const now = Date.now();
            if (fingersClosed && (now - lastGestureTime > 1500)) {
                // Trigger Shape Switch
                lastGestureTime = now;
                currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                setShape(shapes[currentShapeIndex]);
            }

        } else {
            isHandPresent = false;
            isPinching = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();


    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        const positionsArr = particles.geometry.attributes.position.array;
        const colorsArr = particles.geometry.attributes.color.array;

        // Dynamic Color based on Hand X Position (Hue cycle)
        const handColor = new THREE.Color();
        if (isHandPresent) {
            // Map X (-15 to 15) to Hue (0 to 1)
            const hue = (handPos.x + 15) / 30; 
            handColor.setHSL(hue, 1.0, 0.5);
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // 1. Get Base Target (Morphing)
            let tx = targets[i3];
            let ty = targets[i3 + 1];
            let tz = targets[i3 + 2];

            // 2. Apply Interaction (Hand Physics)
            if (isHandPresent) {
                // Calculate distance from particle to hand
                const dx = positionsArr[i3] - handPos.x;
                const dy = positionsArr[i3] - handPos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (isPinching) {
                    // ATTRACTION (Black Hole effect)
                    if (dist < 10) {
                        tx = handPos.x + (Math.random()-0.5); 
                        ty = handPos.y + (Math.random()-0.5);
                        tz = (Math.random()-0.5) * 5;
                    }
                } else {
                    // REPULSION / TURBULENCE
                    if (dist < 5) {
                        const force = (5 - dist) * 2;
                        tx += (dx / dist) * force;
                        ty += (dy / dist) * force;
                    }
                }

                // 3. Update Colors
                // Lerp towards hand color if close, otherwise white/random
                if (dist < 8) {
                    colorsArr[i3] = THREE.MathUtils.lerp(colorsArr[i3], handColor.r, 0.1);
                    colorsArr[i3+1] = THREE.MathUtils.lerp(colorsArr[i3+1], handColor.g, 0.1);
                    colorsArr[i3+2] = THREE.MathUtils.lerp(colorsArr[i3+2], handColor.b, 0.1);
                } else {
                    // Slowly fade back to white/blueish
                    colorsArr[i3] = THREE.MathUtils.lerp(colorsArr[i3], 0.2, 0.02);
                    colorsArr[i3+1] = THREE.MathUtils.lerp(colorsArr[i3+1], 0.6, 0.02);
                    colorsArr[i3+2] = THREE.MathUtils.lerp(colorsArr[i3+2], 1.0, 0.02);
                }
            }

            // 4. Update Position (Lerp current to target)
            positionsArr[i3] += (tx - positionsArr[i3]) * TRANSITION_SPEED;
            positionsArr[i3+1] += (ty - positionsArr[i3+1]) * TRANSITION_SPEED;
            positionsArr[i3+2] += (tz - positionsArr[i3+2]) * TRANSITION_SPEED;
        }

        // Global Rotation for style
        particles.rotation.y = time * 0.1;

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;

        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>